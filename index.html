<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chess Vision">
    <meta name="theme-color" content="#0d1117">
    <link rel="manifest" href="manifest.json">
    <title>Chess Vision</title>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=Crimson+Pro:wght@600&display=swap');

        * { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }

        :root {
            --bg:       #0d1117;
            --surface:  #161b22;
            --primary:  #58a6ff;
            --text:     #c9d1d9;
            --dim:      #8b949e;
            --success:  #3fb950;
            --error:    #f85149;
            --warning:  #d29922;
            --border:   #30363d;
        }

        body { font-family:'Space Grotesk',sans-serif; background:var(--bg); color:var(--text); min-height:100vh; }

        .container { max-width:560px; margin:0 auto; padding:20px; }

        /* â”€â”€ Header â”€â”€ */
        .header { text-align:center; padding:36px 0 24px; }
        .header h1 { font-family:'Crimson Pro',serif; font-size:2.6rem; color:var(--primary); letter-spacing:-1px; }
        .header p  { color:var(--dim); font-size:.8rem; letter-spacing:3px; text-transform:uppercase; margin-top:6px; }

        /* â”€â”€ Card â”€â”€ */
        .card { background:var(--surface); border:1px solid var(--border); border-radius:12px; padding:22px; margin-bottom:14px; }
        .card-title { font-size:1rem; font-weight:700; color:var(--primary); margin-bottom:16px; display:flex; align-items:center; gap:8px; }

        /* â”€â”€ Form â”€â”€ */
        .form-group { margin-bottom:16px; }
        .form-group label { display:block; margin-bottom:6px; color:var(--dim); font-size:.8rem; font-weight:600; text-transform:uppercase; letter-spacing:1px; }
        .form-group select { width:100%; padding:11px; background:var(--bg); border:1px solid var(--border); border-radius:8px; color:var(--text); font-family:'Space Grotesk',sans-serif; font-size:.95rem; }
        .form-group select:focus { outline:none; border-color:var(--primary); }

        /* â”€â”€ Buttons â”€â”€ */
        .btn { width:100%; padding:15px; border:none; border-radius:8px; font-family:'Space Grotesk',sans-serif; font-size:.95rem; font-weight:700; cursor:pointer; transition:opacity .15s; margin-bottom:10px; }
        .btn:active { opacity:.75; }
        .btn-primary   { background:var(--primary); color:var(--bg); }
        .btn-secondary { background:transparent; color:var(--primary); border:1px solid var(--primary); }
        .btn-danger    { background:transparent; color:var(--error); border:1px solid var(--error); }
        .btn:disabled  { opacity:.4; cursor:not-allowed; }

        /* â”€â”€ Hidden file input â”€â”€ */
        input[type="file"] { display:none; }

        /* â”€â”€ Photo preview â”€â”€ */
        /* Always displayed as 4:3 landscape â€” image letterboxed inside */
        .photo-box {
            width:100%;
            aspect-ratio:4/3;
            background:#000;
            border-radius:10px;
            overflow:hidden;
            margin:16px 0;
            display:flex;
            align-items:center;
            justify-content:center;
            border:1px solid var(--border);
        }
        .photo-box img {
            max-width:100%;
            max-height:100%;
            object-fit:contain;   /* never crop, never zoom */
            display:block;
        }
        .photo-box .placeholder {
            color:var(--dim);
            font-size:.85rem;
            text-align:center;
            padding:20px;
        }

        /* â”€â”€ Calibration overlay â”€â”€ */
        .calib-container {
            position:relative;
            width:100%;
            aspect-ratio:4/3;
            background:#000;
            border-radius:10px;
            overflow:hidden;
            margin:16px 0;
            border:1px solid var(--border);
        }
        .calib-container img {
            width:100%;
            height:100%;
            object-fit:contain;
            display:block;
            user-select:none;
            -webkit-user-select:none;
        }
        /* Semi-transparent mask to highlight the board zone */
        .calib-container canvas {
            position:absolute;
            top:0; left:0;
            width:100%; height:100%;
            touch-action:none;
        }

        /* â”€â”€ Corner handles â”€â”€ */
        .corner-handle {
            position:absolute;
            width:36px; height:36px;
            border-radius:50%;
            background:var(--primary);
            border:3px solid #fff;
            transform:translate(-50%,-50%);
            cursor:grab;
            touch-action:none;
            display:flex; align-items:center; justify-content:center;
            font-size:9px; font-weight:700; color:#fff;
            box-shadow:0 2px 8px rgba(0,0,0,.6);
            z-index:10;
        }

        /* â”€â”€ Status â”€â”€ */
        .status { padding:11px 14px; border-radius:8px; margin:12px 0; font-size:.88rem; font-weight:600; border:1px solid; }
        .info    { background:rgba(88,166,255,.1); border-color:var(--primary); color:var(--primary); }
        .success { background:rgba(63,185,80,.1);  border-color:var(--success); color:var(--success); }
        .warning { background:rgba(210,153,34,.1); border-color:var(--warning); color:var(--warning); }
        .error   { background:rgba(248,81,73,.1);  border-color:var(--error);   color:var(--error);   }

        /* â”€â”€ AI Move â”€â”€ */
        .ai-move { background:rgba(88,166,255,.1); border:2px solid var(--primary); border-radius:12px; padding:20px; text-align:center; margin:16px 0; }
        .ai-move .label { font-size:.78rem; color:var(--dim); text-transform:uppercase; letter-spacing:2px; margin-bottom:10px; }
        .ai-move .move  { font-family:'Crimson Pro',serif; font-size:3rem; font-weight:600; color:var(--primary); letter-spacing:4px; }

        /* â”€â”€ History â”€â”€ */
        .history { max-height:220px; overflow-y:auto; background:var(--bg); border-radius:8px; padding:10px; }
        .h-item  { padding:9px 11px; margin:5px 0; background:var(--surface); border-radius:6px; border-left:3px solid var(--primary); display:flex; justify-content:space-between; font-size:.88rem; }
        .h-num   { color:var(--dim); font-weight:600; min-width:28px; }
        .h-moves { font-family:'Courier New',monospace; }

        /* â”€â”€ Screens â”€â”€ */
        .screen { display:none; }
        .screen.active { display:block; animation:fadeIn .25s; }
        @keyframes fadeIn { from{opacity:0} to{opacity:1} }
        .hidden { display:none!important; }

        /* â”€â”€ Loading overlay â”€â”€ */
        .overlay { position:fixed; inset:0; background:rgba(13,17,23,.92); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:999; }
        .spinner { width:48px; height:48px; border:4px solid var(--border); border-top-color:var(--primary); border-radius:50%; animation:spin 1s linear infinite; }
        @keyframes spin { to{transform:rotate(360deg)} }
        .overlay p { margin-top:16px; color:var(--dim); font-size:.9rem; }

        .result-icon { text-align:center; font-size:5rem; margin:16px 0; }
        .info-text   { color:var(--dim); font-size:.85rem; line-height:1.7; }
        .info-text strong { color:var(--text); }
    </style>
</head>
<body>
<div class="container">

    <div class="header">
        <h1>â™” Chess Vision</h1>
        <p>Photo Analysis</p>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SETUP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="setup-screen" class="screen active">
        <div class="card">
            <div class="card-title">âš™ï¸ Configuration</div>

            <div class="form-group">
                <label>Votre couleur</label>
                <select id="player-color">
                    <option value="white">â™” Blancs â€” je commence</option>
                    <option value="black">â™š Noirs â€” l'IA commence</option>
                </select>
            </div>

            <div class="form-group">
                <label>Niveau de l'IA (1 â€“ 20)</label>
                <select id="difficulty">
                    <option value="1">1 â€“ TrÃ¨s facile</option>
                    <option value="3">3 â€“ Facile</option>
                    <option value="5">5 â€“ DÃ©butant</option>
                    <option value="8" selected>8 â€“ IntermÃ©diaire</option>
                    <option value="10">10 â€“ AvancÃ©</option>
                    <option value="12">12 â€“ Difficile</option>
                    <option value="15">15 â€“ Expert</option>
                    <option value="18">18 â€“ MaÃ®tre</option>
                    <option value="20">20 â€“ Maximum</option>
                </select>
            </div>

            <button class="btn btn-primary" onclick="startGame()">DÃ©marrer</button>
        </div>

        <div class="card">
            <div class="card-title">ğŸ“– Fonctionnement</div>
            <p class="info-text">
                <strong>Comment jouer</strong><br><br>
                <strong>1. Calibration</strong><br>
                Avec l'app <strong>Appareil Photo</strong> iOS, tournez l'iPhone en <strong>paysage</strong> et photographiez l'Ã©chiquier entier. Puis revenez ici et sÃ©lectionnez la photo.<br><br>
                <strong>2. Chaque coup</strong><br>
                â€¢ Jouez votre coup sur l'Ã©chiquier<br>
                â€¢ Prenez une photo <strong>en paysage</strong> avec l'app Appareil Photo<br>
                â€¢ Revenez ici et sÃ©lectionnez la photo<br>
                â€¢ L'IA dÃ©tecte et rÃ©pond en UCI<br>
                â€¢ Jouez le coup de l'IA, rÃ©pÃ©tez !<br><br>
                <strong>Si dÃ©tection Ã©choue :</strong> reprenez la photo
            </p>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CALIBRATION â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="calibration-screen" class="screen">
        <div class="card">
            <div class="card-title">ğŸ“ Calibration</div>

            <div id="calib-status" class="status info">
                1ï¸âƒ£ Ouvrez l'app <strong>Appareil Photo</strong> iOS, tournez l'iPhone en paysage, prenez la photo.<br>
                2ï¸âƒ£ Revenez ici et appuyez sur le bouton ci-dessous pour la sÃ©lectionner.
            </div>

            <!-- Hidden input: opens native iOS camera in landscape -->
            <input type="file" id="calib-input"
                   accept="image/*"
                   onchange="onCalibPhoto(event)">

            <!-- Photo + draggable corners -->
            <div class="calib-container hidden" id="calib-container">
                <img id="calib-img" alt="Ã©chiquier">
                <canvas id="calib-canvas"></canvas>
                <!-- Corners injected by JS -->
            </div>

            <button class="btn btn-primary" id="calib-shoot-btn"
                    onclick="document.getElementById('calib-input').click()">
                ğŸ“· Prendre la photo avec l'app Appareil Photo, puis la sÃ©lectionner ici
            </button>

            <button class="btn btn-secondary hidden" id="calib-retry-btn"
                    onclick="retakeCalibPhoto()">
                ğŸ”„ Reprendre / changer la photo
            </button>

            <button class="btn btn-primary hidden" id="calib-validate-btn"
                    onclick="validateCalibration()">
                âœ“ Valider la calibration
            </button>

            <button class="btn btn-secondary" onclick="cancelCalibration()">
                â† Retour
            </button>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• GAME â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="game-screen" class="screen">
        <div class="card">
            <div class="card-title">
                <span id="turn-icon">â™”</span>
                <span id="turn-text">Votre tour</span>
            </div>

            <div id="game-status"></div>

            <div id="ai-move-display" class="ai-move hidden">
                <div class="label">Coup de l'IA</div>
                <div class="move" id="ai-move-text">â€”</div>
            </div>

            <!-- Photo preview (4:3 letterboxed) -->
            <div class="photo-box" id="photo-box">
                <div class="placeholder">La photo apparaÃ®tra ici</div>
            </div>

            <!-- Hidden file input for game photos -->
            <input type="file" id="game-input"
                   accept="image/*"
                   onchange="onGamePhoto(event)">

            <button class="btn btn-primary" id="take-photo-btn"
                    onclick="document.getElementById('game-input').click()">
                ğŸ“· Prendre la photo avec l'app Appareil Photo, puis la sÃ©lectionner ici
            </button>

            <button class="btn btn-secondary hidden" id="retry-btn"
                    onclick="retakeGamePhoto()">
                ğŸ”„ Reprendre / changer la photo
            </button>
        </div>

        <div class="card">
            <div class="card-title">ğŸ“ Historique</div>
            <div class="history" id="history-list">
                <p class="info-text" style="text-align:center">Aucun coup jouÃ©</p>
            </div>
        </div>

        <button class="btn btn-danger" onclick="quitGame()">Abandonner</button>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• RESULT â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="result-screen" class="screen">
        <div class="card">
            <div class="result-icon" id="result-icon">ğŸ†</div>
            <div class="card-title" id="result-title" style="justify-content:center">Partie terminÃ©e</div>
            <p id="result-msg" class="info-text" style="text-align:center;margin:14px 0"></p>
            <div class="history" id="final-history"></div>
            <button class="btn btn-primary" onclick="newGame()">Nouvelle partie</button>
        </div>
    </div>

</div>

<!-- Loading -->
<div id="loading" class="overlay hidden">
    <div class="spinner"></div>
    <p id="loading-text">Chargementâ€¦</p>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     SCRIPTS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
<script>
/* â”€â”€ State â”€â”€ */
const G = {
    chess:       null,
    sf:          null,          // Stockfish worker
    color:       'white',
    difficulty:  8,
    history:     [],
    corners:     null,          // [{x,y} â€¦] as fractions 0-1 of the calib image
    calibImg:    null,          // HTMLImageElement (naturalWidth/Height known)
    refData:     null,          // ImageData of the warped 8Ã—8 grid (reference)
    active:      false
};

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   STOCKFISH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
window.addEventListener('load', initSF);

function initSF() {
    showLoad('Chargement de Stockfishâ€¦');
    try {
        G.sf = new Worker('https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/10.0.2/stockfish.js');
        G.sf.onmessage = (e) => {
            if (e.data.startsWith('bestmove')) {
                const mv = e.data.split(' ')[1];
                if (mv && mv !== '(none)') applyAIMove(mv);
            }
        };
        G.sf.postMessage('uci');
        setTimeout(hideLoad, 900);
    } catch(err) {
        hideLoad();
        alert('Erreur Stockfish â€” vÃ©rifiez votre connexion internet.');
    }
}

function askAI() {
    showLoad('L\'IA rÃ©flÃ©chitâ€¦');
    G.sf.postMessage(`setoption name Skill Level value ${G.difficulty}`);
    G.sf.postMessage(`position fen ${G.chess.fen()}`);
    G.sf.postMessage('go movetime 1000');
}

function applyAIMove(uci) {
    hideLoad();
    try {
        G.chess.move(uci, { sloppy: true });
        G.history.push({ who: 'IA', mv: uci });
        document.getElementById('ai-move-display').classList.remove('hidden');
        document.getElementById('ai-move-text').textContent = uci.toUpperCase();
        setStatus(`âœ… L'IA joue : ${uci.toUpperCase()}`, 'success');
        updateHistory();
        updateTurn();
        if (gameOver()) return;
        setTimeout(() => setStatus('Jouez votre coup â†’ app Appareil Photo (paysage) â†’ revenez sÃ©lectionner la photo', 'info'), 2000);
    } catch(e) {
        setStatus('âŒ Erreur coup IA', 'error');
    }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   SETUP / NEW GAME
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function startGame() {
    G.color      = document.getElementById('player-color').value;
    G.difficulty = +document.getElementById('difficulty').value;
    G.chess      = new Chess();
    G.history    = [];
    G.active     = true;
    G.refData    = null;
    G.corners    = null;
    showScreen('calibration-screen');
    // Reset calibration UI
    document.getElementById('calib-shoot-btn').classList.remove('hidden');
    document.getElementById('calib-retry-btn').classList.add('hidden');
    document.getElementById('calib-validate-btn').classList.add('hidden');
    document.getElementById('calib-container').classList.add('hidden');
    document.getElementById('calib-status').innerHTML =
        '1ï¸âƒ£ Ouvrez l\'app <strong>Appareil Photo</strong> iOS, tournez l\'iPhone en paysage, prenez la photo.<br>' +
        '2ï¸âƒ£ Revenez ici et appuyez sur le bouton ci-dessous pour la sÃ©lectionner.';
}

function newGame() {
    G.history  = [];
    G.refData  = null;
    G.corners  = null;
    showScreen('setup-screen');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   CALIBRATION PHOTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function onCalibPhoto(event) {
    const file = event.target.files[0];
    if (!file) return;
    // Reset input so same file can re-trigger onchange
    event.target.value = '';

    showLoad('Chargement de la photoâ€¦');
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
        hideLoad();
        G.calibImg = img;
        // Show in the container
        const container = document.getElementById('calib-container');
        const imgEl     = document.getElementById('calib-img');
        imgEl.src = url;
        container.classList.remove('hidden');

        // Place the 4 draggable corners at 20%/80% of the displayed image
        setupCornerHandles(container);

        document.getElementById('calib-shoot-btn').classList.add('hidden');
        document.getElementById('calib-retry-btn').classList.remove('hidden');
        document.getElementById('calib-validate-btn').classList.remove('hidden');
        document.getElementById('calib-status').className = 'status info';
        document.getElementById('calib-status').textContent =
            'Glissez les coins ğŸ”µ sur les coins de l\'Ã©chiquier, puis validez';
    };
    img.src = url;
}

function retakeCalibPhoto() {
    document.getElementById('calib-input').click();
}

/* â”€â”€ Corner handles â”€â”€ */
const LABELS = ['a8','h8','h1','a1'];   // TL, TR, BR, BL
const INIT_POS = [               // % of container
    { x:20, y:20 },   // TL
    { x:80, y:20 },   // TR
    { x:80, y:80 },   // BR
    { x:20, y:80 }    // BL
];

function setupCornerHandles(container) {
    // Remove old handles
    container.querySelectorAll('.corner-handle').forEach(h => h.remove());
    // Redraw canvas too
    const canvas = document.getElementById('calib-canvas');
    drawQuad(canvas, INIT_POS);

    INIT_POS.forEach((pos, i) => {
        const h = document.createElement('div');
        h.className = 'corner-handle';
        h.textContent = LABELS[i];
        h.style.left = pos.x + '%';
        h.style.top  = pos.y + '%';

        h.addEventListener('touchstart', e => e.stopPropagation(), { passive:true });
        h.addEventListener('touchmove', e => {
            e.preventDefault();
            const t    = e.touches[0];
            const rect = container.getBoundingClientRect();
            const x = Math.max(0, Math.min(100, (t.clientX - rect.left)  / rect.width  * 100));
            const y = Math.max(0, Math.min(100, (t.clientY - rect.top)   / rect.height * 100));
            h.style.left = x + '%';
            h.style.top  = y + '%';
            // Redraw quad
            drawQuad(canvas, getHandlePositions(container));
        }, { passive: false });

        container.appendChild(h);
    });
}

function getHandlePositions(container) {
    return Array.from(container.querySelectorAll('.corner-handle')).map(h => ({
        x: parseFloat(h.style.left),
        y: parseFloat(h.style.top)
    }));
}

function drawQuad(canvas, positions) {
    const W = canvas.offsetWidth  || canvas.clientWidth;
    const H = canvas.offsetHeight || canvas.clientHeight;
    canvas.width  = W;
    canvas.height = H;
    if (!W || !H) return;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, W, H);
    ctx.strokeStyle = 'rgba(88,166,255,0.6)';
    ctx.lineWidth   = 2;
    ctx.beginPath();
    positions.forEach((p, i) => {
        const x = p.x / 100 * W;
        const y = p.y / 100 * H;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.closePath();
    ctx.stroke();
}

function validateCalibration() {
    const container = document.getElementById('calib-container');
    const positions = getHandlePositions(container);

    // Convert % â†’ fraction 0-1
    G.corners = positions.map(p => ({ x: p.x / 100, y: p.y / 100 }));

    // Capture reference ImageData from the calibration image
    G.refData = warpBoard(G.calibImg, G.corners);

    showLoad('Calibration enregistrÃ©eâ€¦');
    setTimeout(() => {
        hideLoad();
        showScreen('game-screen');
        // Reset game photo UI
        resetGamePhotoUI();
        if (G.color === 'black') {
            setStatus('ğŸ¤– L\'IA commenceâ€¦', 'info');
            setTimeout(askAI, 800);
        } else {
            updateTurn();
            setStatus('Jouez votre coup â†’ app Appareil Photo (paysage) â†’ revenez sÃ©lectionner la photo', 'info');
        }
    }, 800);
}

function cancelCalibration() {
    showScreen('setup-screen');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME PHOTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function onGamePhoto(event) {
    const file = event.target.files[0];
    if (!file) return;
    event.target.value = '';

    showLoad('Analyse de la photoâ€¦');
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
        // Show preview in photo-box (letterboxed 4:3)
        const box = document.getElementById('photo-box');
        box.innerHTML = `<img src="${url}" alt="photo">`;

        // Analyse
        analyzeMove(img);
    };
    img.src = url;
}

function retakeGamePhoto() {
    document.getElementById('game-input').click();
}

function resetGamePhotoUI() {
    document.getElementById('photo-box').innerHTML =
        '<div class="placeholder">La photo apparaÃ®tra ici</div>';
    document.getElementById('take-photo-btn').classList.remove('hidden');
    document.getElementById('retry-btn').classList.add('hidden');
    document.getElementById('ai-move-display').classList.add('hidden');
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MOVE DETECTION (basic pixel diff)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
const BOARD_SIZE = 480;   // warp target px
const SQUARES    = 8;
const SQ         = BOARD_SIZE / SQUARES;

/**
 * Warp the board area defined by corners into an BOARD_SIZEÃ—BOARD_SIZE canvas
 * and return the per-square average RGB as a 64-element array.
 */
function warpBoard(img, corners) {
    const W = img.naturalWidth  || img.width;
    const H = img.naturalHeight || img.height;
    const src = [
        { x: corners[0].x * W, y: corners[0].y * H },  // TL
        { x: corners[1].x * W, y: corners[1].y * H },  // TR
        { x: corners[2].x * W, y: corners[2].y * H },  // BR
        { x: corners[3].x * W, y: corners[3].y * H }   // BL
    ];
    const dst = [
        { x:0,          y:0 },
        { x:BOARD_SIZE, y:0 },
        { x:BOARD_SIZE, y:BOARD_SIZE },
        { x:0,          y:BOARD_SIZE }
    ];

    // Draw the full image on a temp canvas, then sample manually (no CSS transform)
    const tmp    = document.createElement('canvas');
    tmp.width    = W; tmp.height = H;
    tmp.getContext('2d').drawImage(img, 0, 0);

    const out    = document.createElement('canvas');
    out.width    = BOARD_SIZE; out.height = BOARD_SIZE;
    const octx   = out.getContext('2d');

    // Compute perspective transform (homography) manually
    const H_mat  = computeHomography(src, dst);

    // For each destination pixel find source pixel (inverse transform)
    const H_inv  = invertHomography(H_mat);
    const dstData = octx.createImageData(BOARD_SIZE, BOARD_SIZE);
    const srcCtx  = tmp.getContext('2d');
    const srcData = srcCtx.getImageData(0, 0, W, H);

    for (let dy = 0; dy < BOARD_SIZE; dy++) {
        for (let dx = 0; dx < BOARD_SIZE; dx++) {
            const [sx, sy] = applyHomography(H_inv, dx, dy);
            const six = Math.round(sx), siy = Math.round(sy);
            if (six < 0 || six >= W || siy < 0 || siy >= H) continue;
            const si = (siy * W + six) * 4;
            const di = (dy  * BOARD_SIZE + dx) * 4;
            dstData.data[di]   = srcData.data[si];
            dstData.data[di+1] = srcData.data[si+1];
            dstData.data[di+2] = srcData.data[si+2];
            dstData.data[di+3] = 255;
        }
    }
    octx.putImageData(dstData, 0, 0);

    // Extract per-square average brightness
    return extractSquares(octx);
}

function extractSquares(ctx) {
    const squares = [];
    for (let row = 0; row < SQUARES; row++) {
        for (let col = 0; col < SQUARES; col++) {
            const data = ctx.getImageData(col*SQ, row*SQ, SQ, SQ).data;
            let sum = 0;
            for (let i = 0; i < data.length; i += 4) {
                sum += 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
            }
            squares.push(sum / (SQ * SQ));
        }
    }
    return squares;
}

function analyzeMove(img) {
    if (!G.refData || !G.corners) {
        hideLoad();
        setStatus('âŒ Calibration manquante â€” recalibrez', 'error');
        return;
    }

    const currentSquares = warpBoard(img, G.corners);
    const THRESHOLD = 18;   // brightness diff to flag a changed square

    // Squares that changed significantly
    const changed = [];
    for (let i = 0; i < 64; i++) {
        if (Math.abs(currentSquares[i] - G.refData[i]) > THRESHOLD) {
            const col  = i % 8;
            const row  = Math.floor(i / 8);
            const file = String.fromCharCode(97 + (G.color === 'white' ? col : 7 - col));
            const rank = G.color === 'white' ? 8 - row : row + 1;
            changed.push({ i, square: file + rank, before: G.refData[i], after: currentSquares[i] });
        }
    }

    hideLoad();

    if (changed.length < 2 || changed.length > 4) {
        // Detection unclear â†’ ask retry
        setStatus(`âš ï¸ DÃ©tection incertaine (${changed.length} case(s) modifiÃ©e(s)). Reprenez la photo.`, 'warning');
        document.getElementById('retry-btn').classList.remove('hidden');
        document.getElementById('take-photo-btn').classList.add('hidden');
        return;
    }

    // Heuristic: the square that became "emptier" is the origin,
    //            the square that became "fuller" is the destination.
    const sorted   = changed.sort((a, b) => (a.after - a.before) - (b.after - b.before));
    const fromSq   = sorted[0].square;   // became darker/emptier
    const toSq     = sorted[sorted.length - 1].square;   // became brighter/fuller
    const detectedMove = fromSq + toSq;

    // Try to apply
    const legal = G.chess.moves({ verbose: true }).map(m => m.from + m.to + (m.promotion || ''));
    const match = legal.find(m => m.startsWith(detectedMove));

    if (match) {
        commitPlayerMove(match, currentSquares);
    } else {
        setStatus(`âš ï¸ Coup dÃ©tectÃ© (${detectedMove}) invalide. Reprenez la photo.`, 'warning');
        document.getElementById('retry-btn').classList.remove('hidden');
        document.getElementById('take-photo-btn').classList.add('hidden');
    }
}

function commitPlayerMove(uci, newSquares) {
    G.chess.move(uci, { sloppy: true });
    G.refData = newSquares;           // update reference
    G.history.push({ who: 'Vous', mv: uci });

    document.getElementById('retry-btn').classList.add('hidden');
    document.getElementById('take-photo-btn').classList.remove('hidden');
    document.getElementById('ai-move-display').classList.add('hidden');

    setStatus(`âœ… Coup jouÃ© : ${uci.toUpperCase()}`, 'success');
    updateHistory();
    updateTurn();

    if (gameOver()) return;
    setTimeout(askAI, 800);
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   PERSPECTIVE HOMOGRAPHY (minimal)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function computeHomography(src, dst) {
    // 4-point Direct Linear Transform (DLT) â€” enough for a planar board
    const A = [];
    for (let i = 0; i < 4; i++) {
        const {x:sx, y:sy} = src[i];
        const {x:dx, y:dy} = dst[i];
        A.push([-sx,-sy,-1, 0,  0,  0, dx*sx, dx*sy, dx]);
        A.push([ 0,  0,  0,-sx,-sy,-1, dy*sx, dy*sy, dy]);
    }
    const h = solveHomogeneousLeastSquares(A);
    return [
        [h[0],h[1],h[2]],
        [h[3],h[4],h[5]],
        [h[6],h[7],h[8]]
    ];
}

function solveHomogeneousLeastSquares(A) {
    // Simplified SVD via normal equation â€” adequate for 4-point exact solve
    // Use Gaussian elimination on Aáµ€A
    const n = 9, m = A.length;
    // Build Aáµ€A
    const ATA = Array.from({length:n}, () => new Array(n).fill(0));
    for (let i = 0; i < n; i++)
        for (let j = 0; j < n; j++)
            for (let k = 0; k < m; k++)
                ATA[i][j] += A[k][i] * A[k][j];

    // Power iteration to find smallest eigenvector (null-space)
    // Fallback: just normalise last row for approximate solution
    // For a clean 4-point DLT we can compute exactly:
    return dlt4(A);
}

function dlt4(A) {
    // 8 equations, 9 unknowns â†’ set h8=1, solve 8Ã—8 system
    const mat = A.slice(0, 8).map(row => row.slice(0, 8));
    const rhs = A.slice(0, 8).map(row => -row[8]);
    const h   = gaussianElimination(mat, rhs);
    return [...h, 1];
}

function gaussianElimination(A, b) {
    const n = b.length;
    // Augmented matrix
    const M = A.map((row, i) => [...row, b[i]]);
    for (let col = 0; col < n; col++) {
        let maxRow = col;
        for (let row = col+1; row < n; row++)
            if (Math.abs(M[row][col]) > Math.abs(M[maxRow][col])) maxRow = row;
        [M[col], M[maxRow]] = [M[maxRow], M[col]];
        for (let row = col+1; row < n; row++) {
            const f = M[row][col] / M[col][col];
            for (let k = col; k <= n; k++) M[row][k] -= f * M[col][k];
        }
    }
    const x = new Array(n).fill(0);
    for (let i = n-1; i >= 0; i--) {
        x[i] = M[i][n];
        for (let j = i+1; j < n; j++) x[i] -= M[i][j] * x[j];
        x[i] /= M[i][i];
    }
    return x;
}

function invertHomography(H) {
    const [[a,b,c],[d,e,f],[g,h,k]] = H;
    const det = a*(e*k-f*h) - b*(d*k-f*g) + c*(d*h-e*g);
    const inv = [
        [(e*k-f*h)/det, (c*h-b*k)/det, (b*f-c*e)/det],
        [(f*g-d*k)/det, (a*k-c*g)/det, (c*d-a*f)/det],
        [(d*h-e*g)/det, (b*g-a*h)/det, (a*e-b*d)/det]
    ];
    return inv;
}

function applyHomography(H, x, y) {
    const [[a,b,c],[d,e,f],[g,h,k]] = H;
    const w = g*x + h*y + k;
    return [(a*x + b*y + c)/w, (d*x + e*y + f)/w];
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   GAME HELPERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function updateTurn() {
    const myTurn = (G.chess.turn() === 'w') === (G.color === 'white');
    document.getElementById('turn-icon').textContent = myTurn
        ? (G.color === 'white' ? 'â™”' : 'â™š')
        : (G.color === 'white' ? 'â™š' : 'â™”');
    document.getElementById('turn-text').textContent = myTurn ? 'Votre tour' : 'Tour de l\'IA';
}

function gameOver() {
    if (!G.chess.game_over()) return false;
    let msg = 'Match nul', icon = 'ğŸ¤';
    if (G.chess.in_checkmate()) {
        const winner = G.chess.turn() === 'w' ? 'Noirs' : 'Blancs';
        msg = `Ã‰chec et mat ! ${winner} gagnent !`; icon = 'ğŸ†';
    } else if (G.chess.in_stalemate())            msg = 'Pat â€” match nul';
    else if (G.chess.in_threefold_repetition())   msg = 'Triple rÃ©pÃ©tition â€” match nul';
    else if (G.chess.insufficient_material())     msg = 'MatÃ©riel insuffisant â€” match nul';
    endGame(msg, icon);
    return true;
}

function endGame(msg, icon) {
    G.active = false;
    document.getElementById('result-icon').textContent  = icon;
    document.getElementById('result-title').textContent = 'Partie terminÃ©e';
    document.getElementById('result-msg').textContent   = msg;
    document.getElementById('final-history').innerHTML  =
        document.getElementById('history-list').innerHTML;
    showScreen('result-screen');
}

function quitGame() {
    if (confirm('Abandonner la partie ?')) endGame('Partie abandonnÃ©e', 'ğŸ˜”');
}

function updateHistory() {
    const list = document.getElementById('history-list');
    list.innerHTML = '';
    for (let i = 0; i < G.history.length; i += 2) {
        const n  = Math.floor(i/2) + 1;
        const w  = G.history[i];
        const b  = G.history[i+1];
        const el = document.createElement('div');
        el.className = 'h-item';
        el.innerHTML = `
            <span class="h-num">${n}.</span>
            <span class="h-moves">
                ${w ? w.mv.toUpperCase() : 'â€¦'}
                ${b ? ' ' + b.mv.toUpperCase() : ''}
            </span>`;
        list.appendChild(el);
    }
    list.scrollTop = list.scrollHeight;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   UI HELPERS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    document.getElementById(id).classList.add('active');
}

function setStatus(msg, type) {
    const el = document.getElementById('game-status');
    el.className = 'status ' + type;
    el.textContent = msg;
    el.style.display = 'block';
}

function showLoad(msg) {
    document.getElementById('loading-text').textContent = msg;
    document.getElementById('loading').classList.remove('hidden');
}

function hideLoad() {
    document.getElementById('loading').classList.add('hidden');
}
</script>
</body>
</html>
